
\lecture{1}

\section{Класс \(\mathbf{P}\)}

\subsection{Базовые определения}

Будем рассматривать задачи на распознавание, т.е. дан \(A \subset \{0, 1\}^*\) и требуется по \(x \in \{0, 1\}^* \mapsto \left\{\begin{array}{l}
    1, x \in A \\
    0, x \notin A
\end{array}\right.\). Пусть \(M\) решает данную задачу, т.е. \(\forall x (x \in A \Lra M(x) = 1)\).

\begin{definition}
    \(time_M(x)\) --- число шагов \(M(x)\) при вычислении ответа.
\end{definition}

\begin{definition}
    \(time_M(n) = \max_{x: |x| = n} time_M(x)\)
\end{definition}

\begin{definition}
    \(time_M(n) = O(f(n))\), если \(\exists C: \forall n: time_M(n) \le C \cdot f(n)\)
\end{definition}

Возникает вопрос: можно ли сказать, что \(time_A(n) = \min_{M: M \text{ решает }A} time_M(n)\)? Нет, но показать это достаточно сложно (Теорема Блюма).

Поэтому мы приходим к данному определению:
\begin{definition}
    \(\mathbf{DTIME}(t(n)) = \{A | \exists M: M(x) = 1 \Lra x \in A, time_M(n) = O(t(n))\}\)
\end{definition}

Заметим, что для определения \(\mathbf{DTIME}\), необходимо задать модель вычислений. Обычно такой моделью выбирают многоленточную машину Тьюринга.

\begin{definition}
    \(\mathbf{P} = \mathbf{DTIME}(poly(n)) = \bigcup_{k = 1}^\infty \mathbf{DTIME}(n^k)\)
\end{definition}

\textbf{Тезис Черча-Тьюринга в сильной форме}: Любая задача, эффективно решаемая физическим устройстом, решается за полиномиальное время на машине тьюринга.

\begin{example}[Нетривиальные примеры задач из \(\mathbf{P}\)]
    \begin{enumerate}
        \item \(\mathbb{P}\) --- множество простых чисел
        \item Линейное программирование --- как пример, нахождения максимума функции на многограннике. Эта задача не бинарная, но вот задача ''достижима ли это число на многограннике'' принадлежит классу \(\mathbf{P}\).
        \item Симплекс-метод --- алгоритм решения 
    \end{enumerate}
\end{example}

\subsection{Неконструктивные оценки \(\mathbf{P}\)}
Рассмотрим, например, задачу определения графа на планарность. Для этого существует два критерия: критерий Понтрягина-Куратовского: граф планарен \(\Lra\) в нем нет подграфов, гомеоморфных \(K_5, K_{3,3}\). Также, существует критерий Вагнера: граф планарен \(\Lra\) в нем нет миноров \(K_5, K_{3,3}\) (минор --- граф, полученный из исходного удалением и стягиванием ребер). Рассмотрим свойства, которые сохраняются при удалении и стягивании ребер.

\begin{theorem}[Робертсона-Сеймура]
    \begin{enumerate}
        \item Для любого свойства, аналогичного планарности выполнен аналог критерия Вагнера с конечным числом запрещенных миноров.
        \item Наличие такого минора проверяется за полиномиальное время
    \end{enumerate}
\end{theorem}

\begin{corollary}
    Любое такое свойство лежит в классе \(\mathbb{P}\).
\end{corollary}

Но проблема в том, что мы не знаем миноров, которые необходимо проверить, чтобы найти проверить выполнение данного свойства.

\subsection{Другие классы задач}

\begin{definition}
    \(\mathbf{QP} = \mathbf{DTIME}(2^{poly(\log(n))}) = \bigcup_{c = 1}^\infty \mathbf{DTIME}(2^{(\log n)^c})\)
\end{definition}

\begin{definition}
    \(\mathbf{E} = \mathbf{DTIME}(2^{O(n)}) = \bigcup_{c = 1}^\infty \mathbf{DTIME}(2^{cn})\)
\end{definition}

\begin{definition}
    \(\mathbf{EXP} = \mathbf{DTIME}(2^{poly(n)}) = \bigcup_{c = 1}^\infty \mathbf{DTIME}(2^{n^c})\)
\end{definition}

\begin{definition}
    \(\mathbf{EE} = \mathbf{DTIME}(2^{2^{cn}}) = \bigcup_{c = 1}^\infty \mathbf{DTIME}(2^{2^{cn}})\)
\end{definition}

\subsection{Асимптотики различных задач}

\begin{example}
    \(\mathsf{LOG-CLIQUE} = \{G | \omega(G) \ge \log_2 n\} \in \mathbf{QP}\). Является квазиполиномиальной, т.к. \(C_n^{\log n} \le n^{\log n}\), т.е. полный перебор осуществляется за квазиполином
\end{example}

\begin{example}[Задача о доминирующем множестве в турнире]
    непон
\end{example}

\begin{example}
    \(\mathsf{GI} = \{(G_1, G_2): G_1 \cong G_2\} \in \mathbf{QP}\) (изоморфность графов).
\end{example}

\begin{example}
    \(\mathsf{3COL} = \{G: \chi(G) \le 3\} \in E\)
\end{example}

\begin{theorem}[об иерархии по времени]
    Если \(f \ll g \Ra \mathbf{DTIME(f(n))} \subsetneq \mathbf{DTIME(g(n))}\)
\end{theorem}

\lecture{2}

\section{Класс \(\mathbf{NP}\)}

Сейчас будем рассматривать модель вычислений --- \textit{недетерминированную машину Тьюринга} или НМТ. В отличие от обычной машины Тьюринга, функция перехода теперь многозначна (по аналогии с ДКА и НКА). 

Соответственно, время работы такой машины Тьюринга --- \(time_M(x) = \max \#\text{шагов}\) по всем вариантам перехода.

\begin{note}
    Можем считать, что дерево переходов двоичное. Действительно, размер ветвления ограничено мощностью \(|\Sigma|\cdot|Q|\cdot|\{N, R, L\}|\) --- некоторая константа, не зависищая от входа. Тогда каждое \(m\)-ветвление можно заменить \(\log_2 m\) \(2\)-ветвлениями.
\end{note}

Ответ данной машины будем понимать следующее:
\[M(x) = \left\{\begin{array}{l}
    1, \text{существует принимающая ветка} \\
    0, \text{иначе}
\end{array}\right.\]

\begin{note}
    Ответ вычисляется как дизъюнкция по всем результатам работы машины
\end{note}

\begin{definition}
    \(\mathbf{NTIME}(t(n))\) --- класс языков, распознаваемых на НМТ за \(O(t(n))\) шагов
\end{definition}

\begin{definition}
    \(\mathbf{NP} = \bigcup_{c = 1}^\infty \mathbf{NTIME}(n^c)\)
\end{definition}

\begin{definition}
    \(\mathbf{NE} = \bigcup_{c = 1}^\infty \mathbf{NTIME}(2^{cn})\)
\end{definition}

\begin{definition}
    \(\mathbf{NEXP} = \bigcup_{c = 1}^\infty \mathbf{NTIME}(2^{n^c})\)
\end{definition}

\begin{note}
    \(\mathbf{NTIME(t(n))} \subset \mathbf{DTIME(2^{t(n)})}\)
\end{note}

\begin{note}
    \(\mathbf{NP} \subset \mathbf{EXP}\) --- за время \(\mathbf{EXP}\) можно построить все дерево и вычислить ответ по определению.
\end{note}

\subsection{Определение через сертификат}

\begin{theorem}
    \(A \in \mathbf{NP} \Lra \exists V(x, s)\) --- ДМТ, т.ч. \(x \in A \Lra \exists s: V(x, s) = 1\) и \(V(x, s)\) работает за \(poly(|x|)\)
\end{theorem}
\begin{proof}\indent
    \begin{enumerate}
        \item [\(\La\)] Расмотрим следующую НМТ, которая сначала печатает все возможные варианты \(s\) (достаточно написать полиномиальное количество символов, т.к. больше \(V\) не сможет прочесть), а потом на входе \(x, s\) запускает \(V\). Таким образом, Получили машину \(M\), которая в какой-то ветке напечатает нужный сертификат \(s\) и выведет \(V(x, s) = 1\).
        \item [\(\Ra\)] Возьмем в качестве сертификата код нужной ветви в машине \(M\) (0, если надо идти вправо, 1, если влево). Оно и будет нашим сертификатом \(s\). Машина \(V\) будет спускаться, в соответствии с сертификатом, по дереву переходов. Тогда сертификат существует \(\Lra\) сущетсвует принимающая ветвь \(\Lra A \in \mathbf{NP}\).
    \end{enumerate}
\end{proof}

\begin{exercise}
    Сформулировать и доказать аналогичную теорему для классов \(\mathbf{NE}, \mathbf{NEXP}\)
\end{exercise}

\begin{proposition}
    \begin{enumerate}
        \item \(A, B \in \mathbf{P} \Ra A \cap B, A \cup B, \overline{A} \in \mathbf{P}\)
        \item \(A, B \in \mathbf{NP} \Ra A \cap B, A \cup B \in \mathbf{NP}\)
    \end{enumerate}
\end{proposition}

\begin{note}
    Вообще говоря, \(\overline{A} \in \mathbf{NP}\) --- открытый вопрос. Нельзя просто инвертировать значение машины \(M\) (пусть мы получим машину \(\overline{M}\)): тогда \(x \in \overline{A} \Lra\) все ветки \(\overline{M}\) принимающие, а это не то, что мы хотим. Таким образом, мы приходим к следующему определению:
\end{note}

\begin{definition}
    \(\mathbf{coNP} = \{A \in \{0, 1\}^*: \overline{A} \in \mathbf{NP}\}\).
\end{definition}

\begin{note}
    Аналогично можно доказать, что \(A \in \mathbf{coNP}\) тогда и только тогда, когда ответ вычисляется как конъюнкция всех результатов работы машины или тогда и только тогда, когда \(\exists V: x \in A \Lra \forall s V(x, s) = 1\) и \(V\) вычисляется полиномиально от длины \(x\).
\end{note}

\begin{example}
    \begin{enumerate}
        \item \(\mathsf{SAT} = \{\phi: \exists x: \phi(x) = 1\} \in \mathbf{NP}\).
        
        Также имеет смысл рассмотреть двойственную задачу (к задаче опровержимости формулы):
        \item \(\mathsf{TAUT} = \{\phi: \exists x: \phi(x) = 1\} \in \mathbf{coNP}\)
    \end{enumerate}
\end{example}

\begin{note}
    Несмотря на доказанную теорему о полноте, вывод не будет являться сертификатом. Действительно, вывод, вообще говоря, не обязан быть полиномиальным и, в таком случае, машина не сможет полностью его прочесть (т.к. работает полиномиально от \(|x|\))
\end{note}

Отдельный интерес у людей науки представляет множество \((\mathbf{coNP} \cap \mathbf{NP}) \setminus \mathbf{P}\). Рассмотрим следующую задачу:

\begin{definition}
    \(\mathsf{FACTORING} = \{(n, a, b): \exists d \in (a, b): d\text{ --- простое и }n \vdots d\}\)
\end{definition}

\begin{proposition}
    \(\mathsf{FACTORING} \in \mathbf{NP} \cap \mathbf{coNP}\).
\end{proposition}
\begin{proof}\indent
    \begin{enumerate}
        \item[\(\in \mathbf{NP}\)] \(d\) --- сертификат
        \item[\(\in \mathbf{coNP}\)] сертификат --- разложение на простые, каждое из которых \(\notin (a, b)\).
    \end{enumerate}
\end{proof}

\subsection{Некоторые следствия из определений}
\begin{proposition}
    \(\mathbf{P} = \mathbf{NP} \Lra \mathbf{P} = \mathbf{coNP}\)
\end{proposition}
\begin{proposition}
    Следует из того, что \(\mathbf{coP} = \mathbf{P}\) (\(\mathbf{P}\) замкнут относительно дополнения).
\end{proposition}

\begin{note}
    Тем не менее, может быть, что \(\mathbf{P} \ne \mathbf{NP}\), но \(\mathbf{NP} = \mathbf{coNP}\)
\end{note}

\begin{definition}
    \(A \le_p B\) сводится по Карпу (сводится полиномиально), если \(\exists\) всюду полиномиально вычислимая от \(|x|\) функция \(f(x)\), такая, что \(x \in A \Lra f(x) \in B\).
\end{definition}

\begin{definition}
    \(\mathsf{INDSET} = \{(G, k): \text{в графе \(G\) есть антиклика из \(k\) вершин}\}\)
\end{definition}

\begin{example}
    \(\mathsf{CLIQUE} \le_p \mathsf{INDSET}\). Действительно, \(f(G, k) = f(\overline{G}, k)\) (дополнение по ребрам).
\end{example}

\begin{definition}
    \(\mathsf{4COL} = \{G: \exists \text{правильная раскраска в 4 цвета}\}\)
\end{definition}

\begin{example}
    \(\mathsf{4COL} \le_p \mathsf{SAT}\). Мы так уже делали на матлоге, когда сводили некоторые задачи к задачам выполнимости формулы. Для каждой вершины заведем две переменные \(p_i, q_i\), отвечающие за цвет. Нам нужно для каждого ребра записать, что две вершины, являющиеся его концами, имеют разный цвет, и взять конъюнкцию, т.е:
    \[\bigwedge_{(i, j) \in E} (p_i \ne p_j) \vee (q_i \ne q_j)\]
    Размер данной формулы будет полиномиальным относительно размера графа.
\end{example}

\begin{note}[Свойства \(\le_p\)]\indent
    \begin{enumerate}
        \item \(A \le_p B, B \le_p C \Ra A \le_p C\)
        \item \(A \le_p B, B \in \mathbf{P} \Ra A \in \mathbf{P}\)
        \item \(A \le_p B, B \in \mathbf{NP} \Ra A \in \mathbf{NP}\)
        \item \(A \le_p B \Ra \overline{A} \le_p \overline{B}\)
    \end{enumerate}
\end{note}

\begin{definition}
    Задача \(B \in \mathbf{NPH}\) (\(\mathbf{NP}\)-трудной), если \(\forall A \in \mathbf{NP}: A \le_p B\).
\end{definition}

\begin{definition}
    \(\mathbf{NPC} = \mathbf{NP} \cap \mathbf{NPH}\) (\(\mathbf{NP}\)-полные)
\end{definition}

\begin{corollary}\indent
    \begin{enumerate}
        \item \(B \in \mathbf{NPH}, B \le_p C \Ra C \in \mathbf{NPH}\)
        \item \(B \in \mathbf{NPC}, B \le_p C, C \in \mathbf{NP} \Ra C \in \mathbf{NPC}\)
    \end{enumerate}
\end{corollary}

\begin{proposition}\indent
    \begin{enumerate}
        \item \(\mathbf{P} \cap \mathbf{NPH} \ne \emptyset \Ra \mathbf{P} = \mathbf{NP}\)
        \item \(\mathbf{coNP} \cap \mathbf{NPH} \ne \emptyset \Ra \mathbf{NP} = \mathbf{coNP}\)
    \end{enumerate}
\end{proposition}
\begin{proof}\indent
    \begin{enumerate}
        \setcounter{enumi}{1}
        \item \(B \in \mathbf{NPH}, \mathbf{coNP} \Ra \overline{B} \in \mathbf{NP}\). Теперь, если \(A \le_p B \Ra \overline{A} \le_p \overline{B}\). Отсюда получаем, что \(\overline{A} \in \mathbf{NP}\) и тогда \(\mathbf{NP} \subset \mathbf{coNP}\). Тогда:
        \[S \in \mathbf{coNP} \Ra \overline{S} \in \mathbf{NP} \Ra \overline{S} \in \mathbf{coNP} \Ra S \in \mathbf{NP}\]
    \end{enumerate}
\end{proof}

\begin{proposition}
    \(A \in \mathbf{P}, B, \overline{B} \ne \emptyset \Ra A \le_p B\)
\end{proposition}
\begin{proof}
    Рассмотрим 
    \[f(x) = \left\{\begin{array}{l}
        \in B, x \in A \\
        \notin B, x \notin A
    \end{array}\right.\]
\end{proof}

\begin{corollary}
    \(\mathbf{P} = \mathbf{NP} \Ra \mathbf{NPC} = P \setminus \{\emptyset, \Sigma^*\}\)
\end{corollary}

\begin{definition}
    \(\mathsf{TMSAT} = \{(M, x, 1^t): \exists y\;\;M(x, y)\text{ и работает за }\le t\text{ шагов}\}\).
\end{definition}

\begin{proposition}
    \(\mathsf{TMSAT} \in \mathbf{NP}\)
\end{proposition}
\begin{proof}
    Сертификат --- \(y\), верификатор --- УМТ
\end{proof}

\begin{proposition}
    \(\mathsf{TMSAT} \in \mathbf{NPC}\)
\end{proposition}
\begin{proof}
    Принадлежность \(\mathbf{NP}\) уже доказали, докажем принадлежность \(\mathbf{NPC}\). Пусть \(A \in \mathbf{NP}\). По определению: \(x \in A \Lra \exists s: V(x, s) = 1\). Положим \(M\) --- машину Тьюринга, вычисляющую \(V\), \(t(n)\) --- время работы \(V\) для \(|x| = n\). Тогда положим \(f(x) = (M, x, 1^{t(|x|)})\) и получим, что \(A \le_p \mathsf{TMSAT}\).
\end{proof}

\lecture{3}

\begin{definition}
    \(\mathsf{3SAT} = \{\phi | \phi \text{ --- выполнимая 3-КНФ}\}\).
\end{definition}

\begin{theorem}[Преобразование Цейтина]
    \(\mathsf{SAT} \le_p \mathsf{3SAT}\).
\end{theorem}
\begin{proof}
   Для каждой подформулы \(\phi_i\) заведем свою переменную \(p_i\). Тогда достаточно записать, конъюнкцию формул следующего вида: \(q_i \equiv q_j * q_k\), если \(\phi_j = \phi_j * \phi_k\). Осталось для каждой такой формулы написать 3-КНФ.
\end{proof}

\begin{reminder}
    Наша модель вычислений --- одноленточную ДМТ, где лента бесконечная вправо. Пусть \(\Gamma\) --- ленточный алфавит, \(Q\) --- множество состояний, \(Q \cap \Gamma = \emptyset\). Пусть \(|Q \cup \Gamma| \in (2^{k - 1}, 2^k]\), тогда будем использовать \(k\) бит для кодирования элементов \(Q \cup \Gamma\). Конфигурация ДМТ --- строка \(AqaB, q \in Q, A, B \in \Gamma^*, a \in \Gamma\).
\end{reminder}

\begin{definition}
    Беспрефиксный код --- набор слов, где ни одно из слов не является началом другого
\end{definition}

\begin{definition}
    Беспрефиксное кодирование --- функция, такая, что 
\end{definition}

Пусть также \(x\) --- вход, \(|x| = n\), машина \(V\) работает за \(\le t(n)\) шагов \(\Ra V\) использует \(\le t(n)\) ячеек \(\Ra \) длина любой конфигурации \(\le t(n) + c\). Также будем считать, что машина имеет два завершающих состояния: \(q_{accept}, q_{reject}\), прчием после того, как она пришла в одно из них, она может еще какое-то время передвигаться по ленте, ничего не меняя.

\begin{theorem}[Кука-Левина]
    \(\mathsf{SAT} \in \mathbf{NPC}\)
\end{theorem}
\begin{proof}
    Рассмотрим \(V\) --- верификатор \(\mathsf{SAT}\). Покажем, как написать следюущую формулу: ''из данных \(x\), данных \(y\) машина придет в \(q_a\)''. Рассмотрим следуюшую таблицу (индекс столбца --- номер ячейки, индекс строки --- индекс в конфигурации):
    \[\begin{array}{c|c|c|c|c|c|}
        & 0 & 1 & 2 & \dots & t(n) \\
        \hline
        0 & & & & & \\
        \hline
        1  & & & & & \\
        \hline
        2  & & & & & \\
        \hline
        \vdots  & & & & & \\
        \hline
        t(n)  & & & & & \\
        \hline
    \end{array}\]
    Пусть \(p_{ij}\) --- \(k\)-бит, которые стоят в \(ij\)-ой клетке данной таблицы. Запишем формулу, утверждающую, что таблица корректная для \(V\). Тогда наша формула будет иметь вид: \(\phi = \phi_{start} \wedge \phi_{accept} \wedge \phi_{step}\), где:
    \begin{enumerate}
        \item \(\phi_{start}\) определяет, что изначально машина находилась в корректной конфигурации (изначальная конфигурация \(q_1 x\#y\#\dots\#\)), т.е., что \(p_0 = q_1 x\#y\#\dots\#\):
        
        \[\begin{array}{cl}
            \phi_{start} & = \underbrace{(p_{00} = q_1)}_{q_1} \wedge \underbrace{(p_{01} = x_1) \wedge \dots \wedge (p_{0n} = x_n)}_{x} \wedge \underbrace{(p_{0, n+1} = \#)}_{\#} \wedge \\
            & \wedge \underbrace{(p_{0, n + 2} = 0 \vee p_{0, n + 2} = 1) \wedge \dots \wedge (p_{0, n + m + 1} = 0 \vee p_{0, n + m + 1} = 1)}_{y} \wedge \\
            & \wedge \underbrace{(p_{0, n + m + 2} = \#) \wedge \dots \wedge (p_{0, t(n)} = \#)}_{\#\dots\#}
        \end{array}\]
        % \[\phi_{start} = \underbrace{(p_{00} = q_1)}_{q_1} \wedge \underbrace{(p_{01} = x_1) \wedge \dots \wedge (p_{0n} = x_n)}_{x} \wedge \underbrace{(p_{0, n+1} = \#)}_{\#} \wedge\]
        % \[\wedge \underbrace{(p_{0, n + 2} = 0 \vee p_{0, n + 2} = 1) \wedge \dots \wedge (p_{0, n + m + 1} = 0 \vee p_{0, n + m + 1} = 1)}_{y} \wedge \underbrace{(p_{0, n + m + 2} = \#) \wedge \dots \wedge (p_{0, t(n)} = \#)}_{\#\dots\#}\]
        \item \(\phi_{accept}\) проверяет, что в таблице есть хотя бы одно завершающее состояние, т.е., что наша машина завершилась и приняла слово.
        \[\phi_{accept} = \bigvee_{j = 0}^{t(n)} (p_{t(n), j} = q_{accept})\]
        \item \(\phi_{step}\) проверяет, что в машина совершала все переходы корректно. Действительно, для таблицы символ \(p_{ij}\) однозначно восстанавливается по \(p_{i-1, j-1}, p_{i-1, j}, p_{i-1, j+1}, p_{i-1, j+2}\):
        \[\begin{array}{c|c|c|c|c|c}
            & & & & & \\
            \hline
            & p_{i-1, j-1} & p_{i-1, j} &  p_{i-1, j+1} & p_{i-1, j+2} & \\
            \hline
            & & p_{ij} & & & \\
            \hline
            & & & & & \\
        \end{array}\]
        Тогда 
        \[\phi_{step} = \bigwedge_{i = 1}^{t(n)}\bigwedge_{j = 1}^{t(n)} (p_{ij} = f(p_{i-1, j-1}, p_{i-1, j}, p_{i-1, j+1}, p_{i-1, j+2}))\]
        Где \(f\) --- функция, которая восстанавливает по \(p_{i-1, j-1}, p_{i-1, j}, p_{i-1, j+1}, p_{i-1, j+2}\) значение \(p_{ij}\).
    \end{enumerate}
    Тогда формула выполнима \(\Lra V\) приняло изначальную формулу \(\Ra\) получили требуемое
\end{proof}

\begin{definition}
    \(\mathsf{NAE-3SAT}\) --- Дана 3-КНФ. Есть ли набор значений, такой, что в каждой скобке есть истинные и ложные литералы?
\end{definition}

\begin{proposition}
    \(\mathsf{3SAT} \le_p \mathsf{NAE-3SAT}\)
\end{proposition}
\begin{proof}
    Рассмотрим преобразование:
    \[(a_i \vee b_i \vee c_i) \mapsto (a_i \vee b_i \vee x_i) \wedge (\neg x_i \vee c_i \vee z)\]
    Где \(x_i\) уникально для каждого \(i\), а \(z\) одно для всей формулы.

    Покажем, что исходная формула $\phi$ выполнима тогда и только тогда, когда построенная формула $\psi$ принадлежит $\mathsf{NAE-3SAT}$.
    
    В одну сторону: если $\phi$ выполнима, выберем выполняющее назначение и положим $z = 0$. Для каждой скобки $(a_i \vee b_i \vee c_i)$ подберём $x_i$ так, чтобы обе скобки $(a_i \vee b_i \vee x_i)$ и $(\neg x_i \vee c_i \vee 0)$ удовлетворяли условию NAE. Значение \(x_i\) можно взять из следующей таблицы истинности:
    \[\begin{array}{ccccc|cccccccccccc}
        a_i & \vee & b_i & \vee & c_i & & (a_i & \vee & b_i & \vee & c_i) & \wedge & (\neg x_i & \vee & c_i & \vee & z) \\
        \hline
        0 & & 0 & & 1 & & 0 & & 0 & & 1 & & 0 & & 1 & & \\
        0 & & 1 & & 0 & & 0 & & 1 & & 0 & & 1 & & 0 & & \\
        0 & & 1 & & 1 & & 0 & & 1 & & 1 & & 0 & & 1 & & \\
        1 & & 0 & & 0 & & 1 & & 0 & & 0 & & 1 & & 0 & & \\
        1 & & 0 & & 1 & & 1 & & 0 & & 1 & & 0 & & 1 & & \\
        1 & & 1 & & 0 & & 1 & & 1 & & 0 & & 1 & & 0 & & \\
        1 & & 1 & & 1 & & 1 & & 1 & & 0 & & 1 & & 1 & & \\
    \end{array}\]
    Таким образом, полученное назначение даёт решение $\mathsf{NAE-3SAT}$ для $\psi$.
    
    В обратную сторону: пусть $\psi$ имеет решение в смысле $\mathsf{NAE-3SAT}$. Если в этом решении $z = 1$, то инвертируем все переменные (включая $z$) — полученный набор также будет решением, поскольку условие NAE инвариантно относительно отрицания. Поэтому можно считать, что $z = 0$. Тогда для каждой исходной скобки $(a_i \vee b_i \vee c_i)$ имеем две скобки: $(a_i \vee b_i \vee x_i)$ и $(\neg x_i \vee c_i \vee 0)$. Из условия NAE для второй скобки при $z=0$ получаем, что $\neg x_i \vee c_i$ истинно (иначе все литералы были бы ложны). Для первой скобки условие NAE означает, что не все три литерала равны. Совокупность этих условий влечёт истинность $a_i \vee b_i \vee c_i$: действительно, если бы $a_i=b_i=c_i=0$, то из первой скобки следовало бы $x_i=1$ (чтобы не все нули), но тогда вторая скобка стала бы $(\neg 1 \vee 0 \vee 0) = (0 \vee 0 \vee 0)$ — все ложны, противоречие. Значит, все исходные скобки истинны, т.е. $\phi$ выполнима.
    
    Таким образом, построенное сведение полиномиально и корректно, откуда $\mathsf{NAE-3SAT} \in \mathbf{NP}$.
\end{proof}

\begin{proposition}
    $\mathsf{NAE-3SAT} \le_p \mathsf{3COL}$.
\end{proposition}
\begin{proof}
    По формуле $\phi$ с переменными $x_1,\dots,x_n$ и дизъюнктами $C_1,\dots,C_m$ (каждый — тройка литералов) строим граф $G$:
    \begin{enumerate}
        \item Три вершины $T,F,B$, соединённые попарно (треугольник).
        \item Для каждой переменной $x$ вершины $x$ и $\neg x$, соединённые ребром, и каждая из них соединена с $B$.
        \item Для каждого дизъюнкта $C=(l_1\lor l_2\lor l_3)$ вершины $c_1,c_2,c_3$, образующие треугольник, и для каждого $i$ вершина $c_i$ соединена с $l_j$, $l_k$, где $\{i,j,k\}=\{1,2,3\}$.
    \end{enumerate}
    Докажем, что $\phi\in\mathsf{NAE-3SAT}\iff \chi(G) \le 3$.
    \begin{description}
        \item[$\Rightarrow$] Пусть $v$ — оценка, в каждом дизъюнкте есть и истинный, и ложный литерал. Красим $T,F,B$ в разные цвета. Вершину $x$ красим цветом $T$, если $v(x)=1$, и $F$ иначе; $\neg x$ — противоположным цветом. В каждом треугольнике дизъюнкта цвета $c_i$ подбираем так: поскольку среди $l_1,l_2,l_3$ есть оба цвета, можно назначить $c_i$ цвет, отличный от цветов двух смежных литералов (существование такой раскраски проверяется перебором случаев).
        \item[$\Leftarrow$] Пусть $G$ правильно раскрашен в 3 цвета. Можно считать, что цвета $T,F,B$ различны. Тогда $x$ и $\neg x$ имеют цвета $T$ и $F$ (так как оба смежны с $B$ и между собой). Положим $v(x)=1$, если $x$ цвета $T$, иначе $0$. В каждом дизъюнкте $C$ вершины $c_1,c_2,c_3$ имеют три разных цвета. Каждая $c_i$ смежна с двумя литералами, поэтому эти литералы не могут иметь цвет $c_i$. Значит, среди трёх литералов не все одинакового цвета.
    \end{description}
    Таким образом, сведение корректно и выполняется за полиномиальное время.
\end{proof}

\begin{definition}
    \(\mathsf{EXACTSETCOVER}\) --- следующая задача: пусть даны \(S_1, \dots S_m \subset \{1, 2, \dots n\}\), надо понять, существует ли \(i_1, \dots i_k\) и \(\bigsqcup_{j = 1}^k S_{i_k} = \{1, \dots m\}\)
\end{definition}

\begin{proposition}
    $\mathsf{3SAT} \le_p \mathsf{EXACTSETCOVER}$.
\end{proposition}
\begin{proof}
    По формуле $\phi$ с переменными $x_1,\dots,x_n$ и дизъюнктами $C_1,\dots,C_m$ (каждый — тройка литералов) строим множество $U$ и семейство подмножеств $\mathcal{F}$.
    \begin{enumerate}
        \item Элементы: для каждой переменной $x_i$: $x_i$ и $\neg x_i$; для каждого дизъюнкта $C_j$: $c_{j1},c_{j2},c_{j3}$ и $d_{C_j}$.
        \item Множества:
        \begin{enumerate}
            \item Для каждого литерала $l$ (т.е. $x_i$ или $\neg x_i$) множество $L_l = \{l\} \cup \{c_{jk}\mid \text{литерал }l\text{ входит в }C_j\text{ на позиции }k\}$.
            \item Для каждого дизъюнкта $C_j$ и каждого непустого $T\subseteq\{1,2,3\}$, $T\ne\{1,2,3\}$ (т.е. $|T|\le2$), множество $M_{j,T} = \{d_{C_j}\} \cup \{c_{jk}\mid k\in T\}$.
        \end{enumerate}
    \end{enumerate}
    Утверждаем: $\phi$ выполнима $\iff$ существует точное покрытие $U$ выбранными множествами.
    \begin{description}
        \item[$\Rightarrow$] Пусть $v$ — выполняющая оценка. Выберем $L_{x_i}$, если $v(x_i)=1$, иначе $L_{\neg x_i}$. Эти множества покрывают все элементы $x_i,\neg x_i$ и все $c_{jk}$, соответствующие истинным литералам. Для каждого $C_j$ пусть $S_j$ — множество позиций истинных литералов. Тогда $S_j\neq\varnothing$. Пусть $T_j=\{1,2,3\}\setminus S_j$ — позиции ложных литералов ($|T_j|\le2$). Выберем $M_{j,T_j}$ (если $T_j=\varnothing$, берём $M_{j,\varnothing}$ — множество $\{d_{C_j}\}$). Эти множества попарно не пересекаются с выбранными $L$ и между собой и покрывают все оставшиеся $c_{jk}$ и $d_{C_j}$.
        \item[$\Leftarrow$] Пусть есть точное покрытие $\mathcal{C}$. Для каждого $i$ ровно одно из $L_{x_i},L_{\neg x_i}$ принадлежит $\mathcal{C}$ (иначе $x_i$ или $\neg x_i$ не покрыты). Задаём $v(x_i)=1$, если $L_{x_i}\in\mathcal{C}$, иначе 0. Для каждого $C_j$ элемент $d_{C_j}$ покрыт некоторым $M_{j,T}$, $T\subseteq\{1,2,3\}$, $|T|\le2$. Тогда $c_{jk}$ при $k\in T$ покрыты этим $M_{j,T}$, а $c_{jk}$ при $k\notin T$ должны быть покрыты $L_l$, т.е. соответствующие литералы истинны. Так как $T\neq\{1,2,3\}$, имеем $k\notin T$ хотя бы для одного $k$, значит, в $C_j$ есть истинный литерал.
    \end{description}
    Следовательно, сведение корректно и полиномиально.
\end{proof}
